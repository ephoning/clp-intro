* clp-intro

** Constraint Logic Programming

Backward execution:

- regular functional:
#+BEGIN_SRC Clojure
(cons 1 '(2 3))  ->  '(1 2 3)
#+END_SRC
- CLP:
#+BEGIN_SRC Clojure
(conso 1 _ '(1 2 3))   ->  _ unifies with '(2 3)
#+END_SRC

** Examples

- Peano number addition:
      - ***see code...***

- List/seq append / concat
      - 'appendo' is built-in, but can we define it ourselves in terms of other o-primitives
      - ***see code...***

** How And When To Use?

Unlikely "in isolation"; more likely embedded within regular Clojure code.
Therefore:

- How to combine / compose with regular functions?
     - calling CLP functions from within regular functions
     - calling regular functions from within CLP functions
- Also: how to compose CLP functions themselves?


** My Hyperbolical View...

  Monads
  - run* scope gets you into a 'Monad': once in you stay in; run* reifies 'q' into a regular value
  - You can introduce values into an lvar through unification (Monad type constructor), NOT assignment

  Quanta
  - lvars are "quantum objects": they are the superposition of states (all possible values)
    that match the current constraints
  - By "looking at them" (i.e., calling 'run*') the "query lvar" 'q' collapses into a regular value

** Questions

- Given a function, is it "easy" (*) to derive the CLP-equivalent?
- Given a non-primitive function F based on primitive P, does that imply that
  CLP-F is also non-primitive and can be expressed using a CLP-P?

- How about Integer / Float arithmetic?
    - Integer is *countable infinite*, so at least a lazy approach could work
    - Float is *uncountable infinite*, so no go
    - or are we restricted to types with *GROUNDED VALUES* / algebraic types? (seem that way, no?)

(*) Easy: we can think of a simple recipe to get from a functional to CLP equivalent implementation


(NOTE TO SELF: render this as HTML in browser with: C-c C-e h o)
